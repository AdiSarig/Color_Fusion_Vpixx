function [resp,rt,tOUT,tOUT_vpixx, acc, PAS]=oneTrial(w,timing,refresh,nQ,trial,address,eeg,params)%% function [resp,rt,tOut]=oneTrial(w,timing,refresh,nQ)%% Master function for one trial in the DCF_MEG paradigm.%% Input parameters:%  w = struct with windows and images%      w.w is main screen handle%      w.wimgbg is background image (blank screen, frame + fix)%      w.wuni is the uniform color field to show before and after wimg%      w.wimg is set of images to display in sequence%      w.frameOnly is background frame w/o fixation mark%  timing = timing structure with fields 'fixation', 'pre', 'img', 'post', 'ITI', 'tResp'%  refresh is the refresh interval of the monitor (1/refreshRate)%  nQ is the number of responses to prompt for on each trial%% Returns:%  resp = subject's response(s) (if any)%         (one for each element of tResp)%  rt = subject's response time(s) (if response given)%         (one for each element of tResp)%  tOUT = timing history for the trial%% Aaron Schurger% April 9, 2009 (wrote it - now needs to be tested)% - tested: OK.%% 23 July 2009: Ran subj 101,  - everything OK.%% 27 Aug 2009: changes to code (AS)%    Introduced 1 sec interval between stimulus onset and subject response.%    Subject waits for flicker of fixation point before giving response to Q1.%    This was added to match paradigm of Del Cul 2007, allowing time for%    evoked potentials before any motor response.%% 1 Sep 2009: changes to code (AS)%    Added line of code to clear lpt port at time of stimulus cutoff.%    This way the duration of the trigger signal is equal to the duration%    of the stimulus image. Just below "erase the image".%% 08 July 2010: modified for use with v02a_osc%global GLif isfield(trial,'blueDot')    blueDot = trial.blueDot;else    blueDot = false;endFLICKER = 0.1;  % time for flicker of fixation point% as cue for subject to respond% NOTE: can't set high priority because would disable subject inputresp=[];rt=-1;keyIsDown = 0; secs = 0; keyCode = zeros(1,3);srect = [1 1 w.dsize]-1;fix_trig = convertTriggers(50); % fixation trigger set to 50PAS = [];startResponseCollection(params.trig.resp)% 1. put up fixation markScreen('DrawTexture',w.w,w.tex.justFrameAndFix,srect,w.lrect,[],0);Screen('DrawTexture',w.w,w.tex.justFrameAndFix,srect,w.rrect,[],0);% Draw pixel triggerpixelTrigger = double(params.ptrig.fixation);glRasterPos2d(params.screen.pos.CTR(1), params.screen.pos.CTR(2)-200);glDrawPixels(size(pixelTrigger, 2), 1, GL.RGB, GL.UNSIGNED_BYTE, uint8(pixelTrigger));%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if eeg    Datapixx('SetDoutValues', fix_trig); % send TTL at the next register writeendDatapixx('SetMarker');                                      % save the onset of the next register writeDatapixx('RegWrPixelSync',pixelTrigger);                    % register write exactly when the pixels appear on screen[ign,tOUT.fixation] = Screen('Flip',w.w);                        % present stimuliDatapixx('RegWrRd');                                        % must read the register before getting the markertOUT_vpixx.fixation = Datapixx('GetMarker');                       % retrieve the saved timing from the registerWaitSecs(0.004);                                            % for triggers to be sent seperatly% Initialize trigger outputDatapixx('SetDoutValues', 0);Datapixx('RegWr');WaitSecs(0.004);%     [ign,tOUT.fixation] = Screen('flip',w.w);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 2. wait fixation time%     WaitSecs(timing.fixation-(refresh/2));Priority(2);%%%SEND CODE%%%if eeg    trigCode = 0;    if blueDot        trigCode = trigCode + 100;    end        if trial.DCF == 1        trigCode = trigCode + 50;    end        if trial.stimCat == 'F'        trigCode = trigCode + 10;    elseif trial.stimCat == 'H'        trigCode = trigCode + 20;    else        trigCode = trigCode + 30;    end        if trial.lEyeBG == 'R'        trigCode = trigCode + 1;    else        trigCode = trigCode + 2;    end    trigCode = convertTriggers(trigCode);end% 3. then draw target and start clockScreen('DrawTexture',w.w,w.tex.imgl,srect,w.lrect,[],0);Screen('DrawTexture',w.w,w.tex.imgr,srect,w.rrect,[],0);% Draw pixel triggerpixelTrigger = double(params.ptrig.image);glRasterPos2d(params.screen.pos.CTR(1), params.screen.pos.CTR(2)-200);glDrawPixels(size(pixelTrigger, 2), 1, GL.RGB, GL.UNSIGNED_BYTE, uint8(pixelTrigger));if blueDot    rx=rand;    ry=rand;    drawBlueDot(w.w,chooseDotLocation(rx,ry,w.lrect));    drawBlueDot(w.w,chooseDotLocation(rx,ry,w.rrect));end% wait fixation timewhile 1    Datapixx('RegWrRd');    t_now = Datapixx('GetTime');    if t_now > tOUT_vpixx.fixation + timing.fixation-(refresh)        break % break one frame before target frame    endend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if eeg    Datapixx('SetDoutValues', trigCode); % send TTL at the next register writeendDatapixx('SetMarker');                                      % save the onset of the next register writeDatapixx('RegWrPixelSync',pixelTrigger);                    % register write exactly when the pixels appear on screen[ign,tOUT.img] = Screen('Flip',w.w,0,1);                        % present stimuliDatapixx('RegWrRd');                                        % must read the register before getting the markertOUT_vpixx.img = Datapixx('GetMarker');                       % retrieve the saved timing from the registerWaitSecs(0.004);                                            % for triggers to be sent seperatly% Initialize trigger outputDatapixx('SetDoutValues', 0);Datapixx('RegWr');WaitSecs(0.004);%     [ign,tOUT.img] = Screen('flip',w.w,0,1);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     if eeg%         null=0;%         par.pause = 5;%         outp(address, trigCode);%         WaitSecs(par.pause/1000);%         outp(address, null);%     end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     %wait stimulus ON duration%     for i=1:timing.nON-1%          Screen('flip',w.w,0,1);%          [keyIsDown,secs, keyCode, deltaSecs] = KbCheck();%          if trial.preview_15 && keyIsDown%              break%          end%          if trial.preview_13 && keyIsDown%              break%          end%     end% resp(1,:) = keyCode;%% 4. erase the image and record stop timeif ~trial.preview_15    Screen('DrawTexture',w.w,w.tex.justFrameAndFix,srect,w.lrect,[],0);    Screen('DrawTexture',w.w,w.tex.justFrameAndFix,srect,w.rrect,[],0);    % Draw pixel trigger    pixelTrigger = double(params.ptrig.fixation);    glRasterPos2d(params.screen.pos.CTR(1), params.screen.pos.CTR(2)-200);    glDrawPixels(size(pixelTrigger, 2), 1, GL.RGB, GL.UNSIGNED_BYTE, uint8(pixelTrigger));        % wait stimulus time    while 1        Datapixx('RegWrRd');        t_now = Datapixx('GetTime');        if t_now > tOUT_vpixx.img + timing.nON*refresh-(refresh)            break % break one frame before target frame        end    end        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    if eeg        Datapixx('SetDoutValues', fix_trig); % send TTL at the next register write    end        Datapixx('SetMarker');                                      % save the onset of the next register write    Datapixx('RegWrPixelSync',pixelTrigger);                    % register write exactly when the pixels appear on screen        [ign,tOUT.clear] = Screen('Flip',w.w,0,1);                        % present fixation        Datapixx('RegWrRd');                                        % must read the register before getting the marker    tOUT_vpixx.clear = Datapixx('GetMarker');                       % retrieve the saved timing from the register        WaitSecs(0.004);                                            % for triggers to be sent seperatly    % Initialize trigger output    Datapixx('SetDoutValues', 0);    Datapixx('RegWr');    WaitSecs(0.004);    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%    %     [ign,tOUT.clear] = Screen('flip',w.w,0,1); % back to frame and fix    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%        % wait stimulus OFF duration    while 1        Datapixx('RegWrRd');        t_now = Datapixx('GetTime');        if t_now > tOUT_vpixx.clear + timing.timeLimit - refresh            break % break one frame before target frame        end    end        %     % wait stimulus OFF duration    %     for i=1:timing.nOFF-1    %         Screen('flip',w.w,0,1);    %     endendPriority(0);%% Responsesif any([trial.preview_15 trial.preview_13 trial.preview_11 trial.post_test])    % trial preview with no time limit    [resp, tOUT_vpixx.resp] = ResponsePixx('GetLoggedResponses',2); % unlimited wait for any response    resp=find(resp(1,:));    if trial.preview_15        tOUT_vpixx.clear = tOUT_vpixx.resp;    end    if strcmpi(trial.stimCat, 'f')        if resp == params.resp.face            acc = 1;            accuracy = 'hit';        elseif resp == params.resp.house            acc = 0;            accuracy = 'FA';        else            acc = 0;            accuracy = 'error';        end    elseif strcmpi(trial.stimCat, 'h')        if resp == params.resp.house            acc = 1;            accuracy = 'hit';        elseif resp == params.resp.face            acc = 0;            accuracy = 'FA';        else            acc = 0;            accuracy = 'error';        end    elseif strcmpi(trial.stimCat, 'b')        acc = 0;        if resp == params.resp.house || resp == params.resp.face            accuracy = 'FA';        else            accuracy = 'error';        end    endelse % time limit responses    [resp, tOUT_vpixx.resp, accuracy] = getResponse(blueDot, tOUT_vpixx.img, timing.timeLimit, params.resp.dot); % retrive response from register device    if resp~= -1        rt(1)=tOUT_vpixx.resp - tOUT_vpixx.img;    else        rt = -1;    endendDatapixx('StopDinLog'); % stop response collectionDatapixx('RegWrRd');switch accuracy % send response triggers    case 'hit'        Datapixx('SetDoutValues', params.trig.resp_hit);        Datapixx('RegWr');        WaitSecs(0.004);        % Initialize digital output after sending a trigger        Datapixx('SetDoutValues', 0);        Datapixx('RegWr');        WaitSecs(0.004);        acc = 1;    case 'miss'        Datapixx('SetDoutValues', params.trig.resp_miss);        Datapixx('RegWr');        WaitSecs(0.004);        % Initialize digital output after sending a trigger        Datapixx('SetDoutValues', 0);        Datapixx('RegWr');        WaitSecs(0.004);        acc = 0;        % Show timeout screen        Screen('DrawTexture',w.w,w.tex.redFrameAndFix,srect,w.lrect,[],0);        Screen('DrawTexture',w.w,w.tex.redFrameAndFix,srect,w.rrect,[],0);        Screen('flip',w.w);        WaitSecs(1);        Screen('DrawTexture',w.w,w.tex.frameOnly,srect,w.lrect,[],0);        Screen('DrawTexture',w.w,w.tex.frameOnly,srect,w.rrect,[],0);        Screen('flip',w.w);        WaitSecs(timing.timeoutDuration-1);    case 'FA'        Datapixx('SetDoutValues', params.trig.resp_FA);        Datapixx('RegWr');        WaitSecs(0.004);        % Initialize digital output after sending a trigger        Datapixx('SetDoutValues', 0);        Datapixx('RegWr');        WaitSecs(0.004);        acc = 0;    case 'CR'        Datapixx('SetDoutValues', params.trig.resp_CR);        Datapixx('RegWr');        WaitSecs(0.004);        % Initialize digital output after sending a trigger        Datapixx('SetDoutValues', 0);        Datapixx('RegWr');        WaitSecs(0.004);        acc = 1;    case 'error'        Datapixx('SetDoutValues', params.trig.resp_error);        Datapixx('RegWr');        WaitSecs(0.004);        % Initialize digital output after sending a trigger        Datapixx('SetDoutValues', 0); % send TTL at the next register write        Datapixx('RegWr');        WaitSecs(0.004);        acc = 0;end%% Keybord response collection% if nQ > 0 || blueDot%     %     tOUT.cue(1) = tOUT.clear; % cutoff of stim is cue to respond%     waitKeysReleased;%     % wait for response (if none yet)%     while ~keyIsDown%         [keyIsDown,secs,keyCode]=KbCheck;%         if nQ==2%             [keyIsDown,secs,keyCode]=KbCheck;%             while ~keyIsDown % & getSecs-tOUT.img < timing.tResp(1)%                 [keyIsDown,secs,keyCode]=KbCheck;%             end%         end%         % here we impose time pressure%         if (secs - tOUT.clear) > timing.timeLimit%             if trial.preview_15 || trial.preview_13 || nQ==2%                 break%             end%             % send the trigger code for not responding%             if eeg%                 trigCodeMissing = 41;%                 null=0;%                 par.pause = 5;%                 outp(address, trigCodeMissing);%                 WaitSecs(par.pause/1000);%                 outp(address, null);%             end%             %timeout%             Screen('DrawTexture',w.w,w.tex.redFrameAndFix,srect,w.lrect,[],0);%             Screen('DrawTexture',w.w,w.tex.redFrameAndFix,srect,w.rrect,[],0);%             Screen('flip',w.w);%             WaitSecs(1);%             Screen('DrawTexture',w.w,w.tex.frameOnly,srect,w.lrect,[],0);%             Screen('DrawTexture',w.w,w.tex.frameOnly,srect,w.rrect,[],0);%             Screen('flip',w.w);%             resp([1,2],:) = [keyCode;keyCode*0];%             rt(1) = secs - tOUT.clear; rt(2) = nan;%             tOUT.resp(1) = secs; tOUT.resp(2) = nan;%             WaitSecs(timing.timeoutDuration-1);%             return%         end%     end%     %     if eeg && keyIsDown%     %         trigCodePress = 40;%     %         null=0;%     %         par.pause = 5;%     %         outp(address, trigCodePress);%     %         WaitSecs(par.pause/1000);%     %         outp(address, null);%     %     end%     % record response%     resp(1,:)=keyCode; % record response%     rt(1)=secs-tOUT.cue(1); % record reaction time to cue%     tOUT.resp(1)=secs; % record abs time of response% end%% PASif nQ == 2    WaitSecs(0.04);    PASTex =  Screen('MakeTexture',w.w,params.instructions.PAS_scale);    lrect_bigger = [w.lrect(1)-180,w.lrect(2)-140, w.lrect(3)+180, w.lrect(4)+140];    rrect_bigger = [w.rrect(1)-180,w.rrect(2)-140, w.rrect(3)+180, w.rrect(4)+140];    Screen('DrawTexture',w.w, PASTex, [],lrect_bigger,[],0);    Screen('DrawTexture',w.w, PASTex, [],rrect_bigger,[],0);%     % flicker fixation point%     Screen('DrawTexture',w.w,w.tex.frameOnly,srect,w.lrect,[],0);%     Screen('DrawTexture',w.w,w.tex.frameOnly,srect,w.rrect,[],0);    [ign,tOUT.PAS_start] = Screen('flip',w.w); % frame only%     Screen('DrawTexture',w.w,w.tex.justFrameAndFix,srect,w.lrect,[],0);%     Screen('DrawTexture',w.w,w.tex.justFrameAndFix,srect,w.rrect,[],0);%     Screen('flip',w.w,tOUT.PAS_start +FLICKER); % back to frame and fix        keyIsDown = 0; secs = 0; keyCode(:) = 0;    waitKeysReleased;    % wait for response (if none yet)    while ~keyIsDown % & getSecs-tOUT.img < timing.tResp(1)        [keyIsDown,secs,keyCode]=KbCheck;    end    % record response    switch KbName(keyCode)        case '0'            PAS.rating = 0;        case '1'            PAS.rating = 1;        case '2'            PAS.rating = 2;        case '3'            PAS.rating = 3;        otherwise            PAS.rating = -1; % error rating    end    PAS.rt=secs-tOUT.PAS_start; % record reaction time to cue    tOUT.PAS_resp = secs; % record abs time of responseend% flicker fixation pointScreen('DrawTexture',w.w,w.tex.frameOnly,srect,w.lrect,[],0);Screen('DrawTexture',w.w,w.tex.frameOnly,srect,w.rrect,[],0);[ign,tmp] = Screen('flip',w.w); % frame onlyScreen('DrawTexture',w.w,w.tex.justFrameAndFix,srect,w.lrect,[],0);Screen('DrawTexture',w.w,w.tex.justFrameAndFix,srect,w.rrect,[],0);Screen('flip',w.w,tmp+FLICKER); % back to frame and fixWaitSecs(0.1);return%-- END --------------------------------------------------function waitKeysReleasedwhile KbCheck;    % waitendfunction loc = chooseDotLocation(rx,ry,rect)xdim=rect(3) - rect(1);ydim=rect(4) - rect(2);% Border thickness is chosen in AddFrameAndFix.m and is set to 1/30 of% the image height/width (175). The dot has a diameter of 8 pixels.xloc=round(rx*(xdim-20))+rect(1)+10;yloc=round(ry*(ydim-20))+rect(2)+10;loc = [xloc,yloc];