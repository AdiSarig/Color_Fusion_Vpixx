function [avgbeta,revList] = findIsoluminance_noCLUT(refColor,calibColor,rgbGamma,varargin)%% function beta = findIsoluminance(refColor,calibColor,rgbGamma)% % Uses subjective flicker perception to determine equiluminance ratio% for a pair of electron guns, with respect to one gun, generally % the brightest one, chosen as a reference.%% Parameters:%    refcolor    -> the reference color (RGB triplet)%    calibColor  -> find beta such that lum(beta*refColor) == lum(calibColor) (RGB triplet)%    rgbGamma    -> monitor gamma (1x3 vector for RGB)%    [noClose]     -> fourth argument (1/0) to indicate that you do NOT%                   want to execute screen('closeall') at the end%% Date: Dec 07, 2004% Author: Aaron Schurger%% 28 Apr 2005% Modified for fMRI scanner (keys available 1, 2, 3, 4, 5)%% 19 Oct 2005% Added varargin at end of argument list, to allow for an additional (optional)% argument that tells the program NOT to close the active window on exit. This% is specifically for the findLumFunc program which calls this program repeatedly.% It is annoying for it to jump back to the MAC desktop in between every run.%% March 2010% Modified to use a 16-bit CLUT (BUT window is 8-bit).%% Ignore that last comment (July 2010)%% Example calling syntax:% >> b = findIsoluminance([0.4 0.5 0],[0.5 0.4 0],[1 1 1])%nBit=8;KbName('UnifyKeyNames');keyNames = keyNamesOnThisComputer;    %%%%%%%%%%%%    nIters = 11;    %%%%%%%%%%%%	beta=1;	avgbeta=nan;	revList = []; % list of reversals%	maxBeta = 1/max(refColor);	minBeta = 1/2^nBit;	betaIncr = 1/2^nBit;	maxColor = refColor / max(refColor);		lastChg = 0; % to keep track of the direction the luminance was changed	             % so we know when there has been a reversal    % Make two-color image    img1 = makeCheckerboard([50,50],[3,3],1); %ones(imgy,imgx);    img2 = 1-makeCheckerboard([50,50],[3,3],1); %zeros(imgy,imgx);;    img1 = floor(img1*255)+1;    img2 = floor(img2*255)+1;        % Make color maps    m = zeros(256,3);    refColor = refColor .^ rgbGamma;    calibColor = calibColor .^ rgbGamma;    m(1,:)=(refColor);%    m(128,:) = [1 1 1];    m(256,:)=(calibColor);    rgbGamma = repmat(rgbGamma,256,1);    try    %HideCursor    ListenChar(2); % suppress output to command window    if length(varargin) == 0        w = initPsychToolboxWindows_noCLUT([],1);    else        w = varargin{1};    end    % since we are not using a CLUT, then we make many textures    betaRange = [0.65:betaIncr:1.35];    nBeta = length(betaRange);    beta = round(nBeta/2);    for i = 1:nBeta        betaTex(i).beta = betaRange(i);        cm = m;        cm(1,:) = (min(refColor*betaRange(i),maxColor));        cm = round(cm*255);        betaTex(i).tex1 = Screen('MakeTexture',w.w,ind2rgb(img1,cm));        betaTex(i).tex2 = Screen('MakeTexture',w.w,ind2rgb(img2,cm));    end    %    ctr = round(w.rect(3:4)/2);    imgSize = size(img1);    destRect = [(ctr-round(imgSize/2))+1 ctr+round(imgSize/2)];    % draw and flip without clearing    Screen('DrawTexture',w.w,betaTex(beta).tex1,[],destRect);    Screen('flip',w.w,0,1);    Screen('DrawTexture',w.w,betaTex(beta).tex2,[],destRect);    Screen('flip',w.w,0,1);    % wait for all keys to be released    keyIsDown=KbCheck;    while keyIsDown        keyIsDown=KbCheck;    end    revList = zeros(1,nIters);    i=0; % reversal counter    while i < nIters        if keyIsDown            toDo = whatToDo(keyIsDown,keyCode);            if iscell(toDo)                toDo = toDo{1};            end            keyIsDown = 0; % added this line 07/26/2007 (AS)            lpt = 0;            switch toDo                case keyNames.space % = 'stay'                    i=i+1;                    revList(i:nIters) = betaTex(beta).beta^(1/mean(rgbGamma([1 2])));                    avgbeta = revList(i);                    break                case keyNames.upArrow                    beta = min(beta + 1,nBeta);                    if lastChg == -1 % this is a reversal                        i=i+1;                        revList(i)=betaTex(beta).beta^(1/mean(rgbGamma([1 2])));                    end                    lastChg = 1;                case keyNames.dnArrow                    beta = max(beta - 1, 1);                    if lastChg == 1 % this is a reversal                        i=i+1;                        revList(i)=betaTex(beta).beta^(1/mean(rgbGamma([1 2])));                    end                    lastChg = -1;                case keyNames.p                    WaitSecs(0.5);                    KbWait;                case keyNames.escape                    Screen('CloseAll');                    ListenChar(1);                    return                otherwise				            end            %%%%%%%%%%%%%%            % leave a bit of time so that small increments can be made with human button press            waitFlashing(w,betaTex(beta).tex1,betaTex(beta).tex2,0,destRect);            waitFlashing(w,betaTex(beta).tex1,betaTex(beta).tex2,0,destRect);            %%%%%%%%%%%%%        end        [keyIsDown,secs,keyCode] = waitFlashing(w,betaTex(beta).tex1,betaTex(beta).tex2,keyIsDown,destRect);    end    % put up blank background    Screen('DrawTexture',w.w,w.tex.blank);    Screen('flip',w.w);    if nargin < 4        Screen('CloseAll');    elseif isempty(varargin{1})        Screen('CloseAll');    else        % do nothing (i.e. do not close window)    end    if isnan(avgbeta) % i.e. if it was not set by a 'stay' command        avgbeta=mean(revList(4:nIters));    end    ShowCursor    ListenChar(1);catch ME    ShowCursor    Screen('closeall')    ListenChar(1);    rethrow(ME);end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function toDo = whatToDo(keyIsDown,keyCode)    toDo = KbName(keyCode);    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%function [keyIsDown,secs,keyCode] = waitFlashing(w,tex1,tex2,keyIsDown,destRect)    if ~(keyIsDown)		[keyIsDown,secs,keyCode]=KbCheck;	end	WaitSecs(0.001);	if ~(keyIsDown)		[keyIsDown,secs,keyCode]=KbCheck;	end	WaitSecs(0.001);	if ~(keyIsDown)		[keyIsDown,secs,keyCode]=KbCheck;    end           Screen('DrawTexture',w.w,tex1,[],destRect);    for i=1:5    	Screen('flip',w.w,0,1);    end	if ~(keyIsDown)		[keyIsDown,secs,keyCode]=KbCheck;	end	WaitSecs(0.001);	if ~(keyIsDown)		[keyIsDown,secs,keyCode]=KbCheck;	end	WaitSecs(0.001);	if ~(keyIsDown)		[keyIsDown,secs,keyCode]=KbCheck;    end        Screen('DrawTexture',w.w,tex2,[],destRect);    for i=1:5    	Screen('flip',w.w,0,1);    end	if ~(keyIsDown)		[keyIsDown,secs,keyCode]=KbCheck;	end